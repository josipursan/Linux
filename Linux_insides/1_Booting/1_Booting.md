# Booting  
-once motherboard receives a *power good* signal from PSU after the power on button has been pushed  
-processor now starts working in *real mode* - this means addresses correspond to real locations in memory CPU is started which then resets any leftover data and sets predefind values in its registers  

-**what is a *power good* signal**?  
&nbsp;&nbsp;&nbsp;-it is a +5V signal generated by the PSU after it has run all of its internal tests and the output voltages have stabilized  
  
  
-memory segmentation - division of computer's primary memory into smaller sections  
&nbsp;&nbsp;&nbsp;-if, for example, our memory is divided into 16-bit memory chunks, we wouldn't be able to address memory above 64KB  
&nbsp;&nbsp;&nbsp;-therefore an alternate method exists, allowing us to do exactly that  
&nbsp;&nbsp;&nbsp;-an address now consists of a *segment selector* (it has the base address), and the offset from this base address : `Physical address = segment selector*16 + offset`  
  
-CS register - **C**ode **S**egment register is used to address the code segment of the memory, i.e. the location in the memory, where code is stored  
&nbsp;&nbsp;&nbsp;-the processor uses CS segment for access to instructions referenced by IP register  
  
-IP register - **I**nstruction **P**ointer register contains the offset within the code segment of memory  
&nbsp;&nbsp;&nbsp;-CS:IP is used to point to the location (ie. calculating the physical address) of the code in memory  
&nbsp;&nbsp;&nbsp;-IP is also called **program counter** - PC simply holds the memory address of the next instruction to be executed  
  
-**reset vector** - default location a CPU will go to to find the first instruction it will execute after a reset  
  
-when booting, this first instruction will usually be a *jmp* to the BIOS entry point  
-now finally the BIOS is starting  
-BIOS initializes and checks the hardware, and then looks for a bootable device  
-boot order is stored in BIOS  
-when attempting to boot from a hard drive, BIOS tries to find a boot sector  
&nbsp;&nbsp;&nbsp;-on hard drives that are MBR partitioned, the boot sector is stored in the first 446 bytes of the first sector  (the final two bytes of the first sector are 0x55 and 0xaa - this designates to BIOS that the device is bootable)  
-after this, BIOS hand over the control to the **bootloader**  
  
-GRUB 2 will be used as an example to exaplain how bootloaders work  
-so, now that BIOS has chosen a boot device, it transfers control to boot sector code, and **boot.img** execution starts  
  
-**boot.img** - a simple piece of code  
&nbsp;&nbsp;&nbsp;-it has a pointer used to jump to the location of GRUB 2's core image  
&nbsp;&nbsp;&nbsp;-the core image begins **diskboot.img**  
  
-**diskboot.img** - usually stored immediately after the first sector in the unused space before the first partition  
&nbsp;&nbsp;&nbsp;-it loads rest of the core image - contains GRUB 2's kernel and drivers for handling fs  
&nbsp;&nbsp;&nbsp;-then **grub_main** function is executed  
  
-**grub_main** - initialies the console, gets the base address for modules, sets the root device, loads/parses the grub configuration file, loads modules, etc.  
&nbsp;&nbsp;&nbsp;-at the end of its all tasks, **grub_main** moves grub to **normal mode**  
  
-**grub_normal_execute** - completes the final preparations and shows us a menu to choose an OS  
&nbsp;&nbsp;&nbsp;-when user selects which OS to boot, `grub_menu_execute_entry` runs and executes grub `boot` command  
  
-not bootloader (GRUB 2 in our example) must read and fill some field of the kernel setup header (this is a header file like any other)  
&nbsp;&nbsp;&nbsp;-some of these values are `ram_size`, `boot_flag`, etc.  
&nbsp;&nbsp;&nbsp;-the bootloader must fill all of the necessary headers with values received from the command line, or with values calculated during the boot  
  
-once bootloader transfers control to kernel, kernel will start at  
`X + sizeof(KernelBootSector) + 1`  
&nbsp;&nbsp;&nbsp;-`X` is the address of the kernel boot sector being loaded  
&nbsp;&nbsp;&nbsp;-**cool tip** : if you want to get the cool memory dump where you will see the kernel boot sector being loaded, check out this : https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-1#bootloader  


# The beginning of the Kernel Setup Stage  
-first the kernel setup does a couple of things such as decompressor setup and memory stuff (probably memory training, not sure though)  
-after all of the setup stuff, kernel gets decompressed and kernel setup execution jumps to the decompressed kernel  
  
-the file, or to be more precies the first function that is executed, starts with *"magic number"* **MZ** - magic number MZ identifies that the file is an MS DOS executable file  
  
-after that there is another *"magic number"* - **PE**  
&nbsp;&nbsp;&nbsp;-PE stands for Portable Executable  
&nbsp;&nbsp;&nbsp;-it is a file format for executables, object code, DLLs, and other such files used in the 32-bit and 64 bit versions of Windows OSes  
&nbsp;&nbsp;&nbsp;-PE format is a data structure carrying information necessary for Windows OS loader to manage the wrapped exectuable code  
  
-MZ and PE magic numbers are necessary to load an OS with UEFI support <small>(all of this will be covered in more detail in the upcoming chapters)</small>  
  
-this is the start of the actual setup : `.globl	_start`  
  
-what is `.byte 0xeb`? - it is a different way of writing `jmp`  
&nbsp;&nbsp;&nbsp;-take a look at this (same logic applies;`nop` can be written as `.byte 0x90`): https://stackoverflow.com/a/33361074  
  
-this `jmp` command leads us to the `start_of_setup-1f` point  
-now you are wondering what is this `1f`?  
&nbsp;&nbsp;&nbsp;-generally `Nf` notation indicates we want to refer to label `N` (e.g. if we have 2f, it means we are refering to label 2)  
  
-after a lot of code, we finally reach `.entrytext` which starts at the `start_of_setup` label, and thus we have finally reached actual running code  
&nbsp;&nbsp;&nbsp;-having reached `start_of_setup`, kernel must :  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-that all segment register values are equal  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-if needed, set up stack correctly  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-set up bss (*bss* stands for **b**lock **s**tarting **s**ymbol, and it is a portion of obj file, exectuable or assembly code that contains statically allocated variables that are declared but not yet assigned a value)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-jump to C code in */arch/x86/boot/main.c*  

# Aligning the Segment Registers  
-kernel ensures `ds` and `es` segment registers point to the same address  
-**ds** - data segment register  
&nbsp;&nbsp;&nbsp;-defines where data from the program will be stored  
  
-**es** - extra segment register  
&nbsp;&nbsp;&nbsp;-can be thought of as an additional regsiter used for far pointer addressing  
  
-direction flag is now also cleared using the `cld` instruction  
&nbsp;&nbsp;&nbsp;-**direction flag** - controls the *left-to-right* or *right-to-left* direction of string processing  
&nbsp;&nbsp;&nbsp;&nbsp;-this flag is used to determine the direction (*forward* or *backward*) in which bytes of data will be copied from one place in the memory, to another  
  
# Stack setup  
-most of the setup code is prep for C lang env to run in real mode  
  
-now register `ss` gets checked  
&nbsp;&nbsp;&nbsp;-**ss** - stack segment register  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-identifies the block of memory that will be used for the stack  
  
# BSS Setup  
-now we need to BSS setup and check the "magic" signatures  
  
-**BSS** - explained a bit above in the document  
&nbsp;&nbsp;&nbsp;-as previously mentioned, linux uses this area to store statically allocated, uninitialized data, and linux makes sure this area of memory is first zeroed  
  
TO DO : Jump to main; Conclusion

![Alternative text if path fails](path/to/image/myImage.jpg "Some alt text")